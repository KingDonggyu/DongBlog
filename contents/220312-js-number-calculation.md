---
date: "2022-03-12"
title: "[JavaScript] 숫자형의 부정확한 계산"
category: "Language"
categoryColor: "darkorchid"
tags: ["JS"]
thumbnail: "./images/JavaScript.png"
---

숫자는 내부적으로 64비트 형식 IEEE-754으로 표현되기 때문에 **숫자를 저장하려면 정확히 64비트가 필요하다.**

64비트 중 **52비트는 숫자를 저장**하는 데 사용되고, **11비트는 소수점 위치**를(정수는 0), **1비트는 부호를 저장**하는 데 사용된다.

<br />

그런데 숫자가 너무 커지면 64비트 공간이 넘쳐서 `Infinity`로 처리된다.

```js
console.log( 1e500 ); // Infinity
```

<br />

또한, 꽤 자주 발생하는 현상인 **정밀도 손실(loss of precision)** 도 있다.

```js
console.log( 0.1 + 0.2 == 0.3 ); // false
```

`0.1`과 `0.2`의 합은 `0.3`이 맞는데..

```js
console.log( 0.1 + 0.2 ); // 0.30000000000000004
```

???

왜 이런 일이 발생하는 걸까?

<br />

숫자는 0과 1로 이루어진 이진수로 변환되어 연속된 메모리 공간에 저장된다.

그런데 10진법을 사용하면 쉽게 표현할 수 있는 `0.1`, `0.2` 같은 **분수는 이진법으로 표현하면 무한 소수가 된다.**

<br />

예를 들어 보자.

`0.3`은 3을 10으로 나눈 수인 `3/10` 이다.  

10진법을 사용하면 이러한 숫자를 쉽게 표현할 수 있다.

하지만, 1/3은 무한 소수` 0.33333(3)`이 된다!!

<br />

이렇게 **`10`의 거듭제곱으로 나눈 값은 10진법에서 잘 동작하지만** `3`으로 나누게 되면 10진법에서 제대로 동작하지 않는다.

같은 이유로 **2진법 체계에서 `2`의 거듭제곱으로 나눈 값은 잘 동작하지만** `1/10`같이 `2`의 거듭제곱이 아닌 값으로 나누게 되면 **무한 소수**가 되어버린다..

그렇다면 어떻게 해결해?

<br />

**IEEE-754에선 가능한 가장 가까운 숫자로 반올림하는 방법을 사용해 이런 문제를 해결한다.**

하지만, 반올림 규칙을 적용하면 발생하는 **'작은 정밀도 손실’** 을 볼 수는 없지만 실제로 손실은 발생한다.

```js
console.log( 0.1.toFixed(20) ); // 0.10000000000000000555
```

그리고 두 숫자를 합하면 '정밀도 손실’도 더해진다..

`0.1 + 0.2`가 정확히 `0.3`이 아닌 이유가 여기에 있다!

그럼 이 문제는 어떻게 해결해?

<br />

가장 신뢰할만한 방법은 **`toFixed(n)`메서드를 사용해 어림수를 만드는 것이다.**

```js
let sum = 0.1 + 0.2;
console.log( sum.toFixed(2) ); // 0.30
```

> `toFixed`는 항상 문자열을 반환한다는 점에 유의해야 한다. 문자열을 반환하기 때문에 소수점 다음에 오는 숫자가 항상 2개가 될 수 있다. 문자형으로 바뀐 숫자를 다시 숫자형으로 강제 변환하려면 단항 덧셈 연산자를 사용하면 된다.

숫자에 임시로 100(또는 더 큰 숫자)을 곱하여 정수로 바꾸고, 원하는 연산을 한 후 다시 100으로 나누는 것도 하나의 방법이 될 수 있다.

```js
console.log( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
```

하지만, 마지막에 나눗셈이 들어가기 때문에 아래 예시와 같이 소수가 다시 등장할 수 있다는 **단점**이 있다.

```js
console.log( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
```

이렇게 10의 거듭제곱을 곱하고 다시 동일한 숫자로 나누는 전략은 **오류를 줄여주긴 하지만 완전히 없애지는 못한다.**

<br />

무한소수를 방지하는 완벽한 방법은 사실 없다고 한다.. 

필요할 때마다 꼬리를 잘라 어림수를 만드는 방법뿐..

<br />

아래 내용부터는 숫자형의 더 정확한 계산을 도울 수 있는 메서드들에 대해 설명하겠다.

(사실 이건 핑계고.. 기록은 하고 싶지만 포스트 하나 더 작성하기 귀찮다 😅)

## isNaN과 isFinite

**`Infinity`와 `-Infinity` : 그 어떤 숫자보다 큰 혹은 작은 특수 숫자 값**

**`NaN` : 에러를 나타내는 값**

위 두 특수 숫자는 숫자형에 속하지만 정상적인 숫자는 아니기 때문에, 정상적인 숫자와 구분하기 위한 특별한 함수가 존재한다.

<br />

- **`isNaN(value)` : 인수를 숫자로 변환한 다음 `NaN`인지 테스트**

```js
console.log( isNaN(NaN) ); // true
console.log( isNaN("str") ); // true
```

그냥 `=== NaN` 비교를 하면 되지 않나..?

```js
console.log( NaN === NaN ); // false
```

`NaN`은 `NaN` 자기 자신을 포함하여 그 어떤 값과도 같지 않다! 그렇기에 필요하다.

<br />

**- `isFinite(value)` : 인수를 숫자로 변환하고 변환한 숫자가 `NaN / Infinity / -Infinity`가 아닌 일반 숫자인 경우 `true`를 반환**

```js
console.log( isFinite("15") ); // true
console.log( isFinite("str") ); // false (NaN이기 때문)
alconsole.logert( isFinite(Infinity) ); // false
```

**`isFinite`는 문자열이 일반 숫자인지 검증하는 데 사용되곤 한다.**

```js
let num = +prompt("숫자를 입력하세요.", '');
alert( isFinite(num) );
```

위 예시에서 숫자가 아닌 값을 입력하거나 `Infinity`, `-Infinity`를 입력하면 `false`가 출력된다.

❗️ **빈 문자열이나 공백만 있는 문자열**은 `isFinite`를 포함한 모든 숫자 관련 내장 함수에서 **`0`으로 취급된다는 점을 주의해야 한다!**

<br />

`Object.is`는 `===`처럼 값을 비교할 때 사용되는 특별한 내장 메서드인데, 

아래와 같은 두 가지 케이스에선 `===`보다 좀 더 신뢰할만한 결과를 보여준다.

**1. `NaN`을 대상으로 비교할 때:** `Object.is(NaN, NaN) === true`

**2. `0`과 `-0`이 다르게 취급되어야 할 때:** `Object.is(0, -0) === false`

> 자바스크립트 내부에서 숫자를 표현하는 방식 때문에 발생하는 또 다른 흥미로운 현상은 `0`과 `-0`이라는 두 종류의 0이 존재한다는 사실이다. **숫자를 나타내는 비트가 모두 0이더라도 부호를 나타내는 비트는 다르므로 `0`과 `-0`은 사실 다른 값이다.**

위 두 케이스를 제외하고는, `Object.is(a, b)와 a === b`의 결과는 같다.

<br />

## parseInt와 parseFloat

단항 덧셈 연산자 `+` 또는 `Number()`를 사용하여 숫자형으로 변형할 때 적용되는 규칙은 꽤 엄격하다.

피연산자가 숫자가 아니면 아래 예시와 같이 형 변환이 실패한다.

```js
console.log( +"100px" ); // NaN
```

엄격한 규칙이 적용되지 않는 유일한 예외는 문자열의 처음 또는 끝에 공백이 있어서 공백을 무시할 때이다.

<br />

내장 함수 `parseInt`와 `parseFloat`는 이런 경우를 위해 만들어졌다.

**두 함수는 불가능할 때까지 문자열에서 숫자를 읽으며, 숫자를 읽는 도중 오류가 발생하면 이미 수집된 숫자를 반환한다!**

```js
console.log( parseInt('100px') ); // 100
console.log( parseFloat('12.5em') ); // 12.5

console.log( parseInt('12.3') ); // 12 (정수 부분만 반환)
console.log( parseFloat('12.3.4') ); // 12.3 (두 번째 점에서 숫자 읽기를 멈춤)
```

<br />

`parseInt`와 `parseFloat`는 **읽을 수 있는 숫자가 없을 때 `NaN`을 반환한다.**

```js
console.log( parseInt('a123') ); // NaN (a는 숫자가 아니므로 바로 중지됨)
```

<br />

`parseInt`를 사용하면 16진수 문자열, 2진수 문자열 등을 파싱할 수도 있다. 

```js
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255 (0x가 없어도 동작)
alert( parseInt('2n9c', 36) ); // 123456
```

<br />
<br />

작성하다보니 내용이 너무 길어져 중간에 꽤 힘들었다..

기록하고 싶은 것은 많은데 또 포스트를 따로 작성하기는 귀찮고..

<br />

## ※ Source

🖥 ko.javascript.info