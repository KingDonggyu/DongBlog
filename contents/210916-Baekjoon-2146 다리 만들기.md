---
date: "2021-09-16"
title: "[Baekjoon] 2146ë²ˆ: ë‹¤ë¦¬ ë§Œë“¤ê¸°"
category: "Algorithm"
categoryColor: "#6196cc"
tags: ["Baekjoon", "Python", "BFS"]
thumbnail: "./images/Baekjoon.png"
---

## ë¬¸ì œ

ì—¬ëŸ¬ ì„¬ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë‚˜ë¼ê°€ ìˆë‹¤. ì´ ë‚˜ë¼ì˜ ëŒ€í†µë ¹ì€ ì„¬ì„ ì‡ëŠ” ë‹¤ë¦¬ë¥¼ ë§Œë“¤ê² ë‹¤ëŠ” ê³µì•½ìœ¼ë¡œ ì¸ê¸°ëª°ì´ë¥¼ í•´ ë‹¹ì„ ë  ìˆ˜ ìˆì—ˆë‹¤. í•˜ì§€ë§Œ ë§‰ìƒ ëŒ€í†µë ¹ì— ì·¨ì„í•˜ì, ë‹¤ë¦¬ë¥¼ ë†“ëŠ”ë‹¤ëŠ” ê²ƒì´ ì•„ê¹ë‹¤ëŠ” ìƒê°ì„ í•˜ê²Œ ë˜ì—ˆë‹¤. ê·¸ë˜ì„œ ê·¸ëŠ”, ìƒìƒ‰ë‚´ëŠ” ì‹ìœ¼ë¡œ í•œ ì„¬ê³¼ ë‹¤ë¥¸ ì„¬ì„ ì‡ëŠ” ë‹¤ë¦¬ í•˜ë‚˜ë§Œì„ ë§Œë“¤ê¸°ë¡œ í•˜ì˜€ê³ , ê·¸ ë˜í•œ ë‹¤ë¦¬ë¥¼ ê°€ì¥ ì§§ê²Œ í•˜ì—¬ ëˆì„ ì•„ë¼ë ¤ í•˜ì˜€ë‹¤.

ì´ ë‚˜ë¼ëŠ” NÃ—Ní¬ê¸°ì˜ ì´ì°¨ì› í‰ë©´ìƒì— ì¡´ì¬í•œë‹¤. ì´ ë‚˜ë¼ëŠ” ì—¬ëŸ¬ ì„¬ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆìœ¼ë©°, ì„¬ì´ë€ ë™ì„œë‚¨ë¶ìœ¼ë¡œ ìœ¡ì§€ê°€ ë¶™ì–´ìˆëŠ” ë©ì–´ë¦¬ë¥¼ ë§í•œë‹¤. ë‹¤ìŒì€ ì„¸ ê°œì˜ ì„¬ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë‚˜ë¼ì˜ ì§€ë„ì´ë‹¤.

<br />

<div style="text-align: center">
    <img src="https://www.acmicpc.net/JudgeOnline/upload/201008/bri.PNG" width="300px">
</div>

ìœ„ì˜ ê·¸ë¦¼ì—ì„œ ìƒ‰ì´ ìˆëŠ” ë¶€ë¶„ì´ ìœ¡ì§€ì´ê³ , ìƒ‰ì´ ì—†ëŠ” ë¶€ë¶„ì´ ë°”ë‹¤ì´ë‹¤. ì´ ë°”ë‹¤ì— ê°€ì¥ ì§§ì€ ë‹¤ë¦¬ë¥¼ ë†“ì•„ ë‘ ëŒ€ë¥™ì„ ì—°ê²°í•˜ê³ ì í•œë‹¤. ê°€ì¥ ì§§ì€ ë‹¤ë¦¬ë€, ë‹¤ë¦¬ê°€ ê²©ìì—ì„œ ì°¨ì§€í•˜ëŠ” ì¹¸ì˜ ìˆ˜ê°€ ê°€ì¥ ì‘ì€ ë‹¤ë¦¬ë¥¼ ë§í•œë‹¤. ë‹¤ìŒ ê·¸ë¦¼ì—ì„œ ë‘ ëŒ€ë¥™ì„ ì—°ê²°í•˜ëŠ” ë‹¤ë¦¬ë¥¼ ë³¼ ìˆ˜ ìˆë‹¤.

<br />

<div style="text-align: center">
    <img src="https://www.acmicpc.net/JudgeOnline/upload/201008/b2.PNG" width="300px">
</div>

ë¬¼ë¡  ìœ„ì˜ ë°©ë²• ì™¸ì—ë„ ë‹¤ë¦¬ë¥¼ ë†“ëŠ” ë°©ë²•ì´ ì—¬ëŸ¬ ê°€ì§€ ìˆìœ¼ë‚˜, ìœ„ì˜ ê²½ìš°ê°€ ë†“ëŠ” ë‹¤ë¦¬ì˜ ê¸¸ì´ê°€ 3ìœ¼ë¡œ ê°€ì¥ ì§§ë‹¤(ë¬¼ë¡  ê¸¸ì´ê°€ 3ì¸ ë‹¤ë¥¸ ë‹¤ë¦¬ë¥¼ ë†“ì„ ìˆ˜ ìˆëŠ” ë°©ë²•ë„ ëª‡ ê°€ì§€ ìˆë‹¤).

ì§€ë„ê°€ ì£¼ì–´ì§ˆ ë•Œ, ê°€ì¥ ì§§ì€ ë‹¤ë¦¬ í•˜ë‚˜ë¥¼ ë†“ì•„ ë‘ ëŒ€ë¥™ì„ ì—°ê²°í•˜ëŠ” ë°©ë²•ì„ ì°¾ìœ¼ì‹œì˜¤.

## ì…ë ¥

ì²« ì¤„ì—ëŠ” ì§€ë„ì˜ í¬ê¸° N(100ì´í•˜ì˜ ìì—°ìˆ˜)ê°€ ì£¼ì–´ì§„ë‹¤. ê·¸ ë‹¤ìŒ Nì¤„ì—ëŠ” Nê°œì˜ ìˆ«ìê°€ ë¹ˆì¹¸ì„ ì‚¬ì´ì— ë‘ê³  ì£¼ì–´ì§€ë©°, 0ì€ ë°”ë‹¤, 1ì€ ìœ¡ì§€ë¥¼ ë‚˜íƒ€ë‚¸ë‹¤. í•­ìƒ ë‘ ê°œ ì´ìƒì˜ ì„¬ì´ ìˆëŠ” ë°ì´í„°ë§Œ ì…ë ¥ìœ¼ë¡œ ì£¼ì–´ì§„ë‹¤.

## ì¶œë ¥

ì²«ì§¸ ì¤„ì— ê°€ì¥ ì§§ì€ ë‹¤ë¦¬ì˜ ê¸¸ì´ë¥¼ ì¶œë ¥í•œë‹¤.

### ì˜ˆì œ ì…ë ¥

```

10
1 1 1 0 0 0 0 1 1 1
1 1 1 1 0 0 0 0 1 1
1 0 1 1 0 0 0 0 1 1
0 0 1 1 1 0 0 0 0 1
0 0 0 1 0 0 0 0 0 1
0 0 0 0 0 0 0 0 0 1
0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 1 1 1 0 0 0
0 0 0 0 0 0 0 0 0 0
```

### ì˜ˆì œ ì¶œë ¥

```

3
```

<hr />

## ğŸ” Algorithm

BFS

## ğŸ’» Language

Python

## ğŸ“ Logic

- **ì…ë ¥ ë° ì£¼ìš” ë³€ìˆ˜ ìƒì„±**

  ```python
  N = int(input())
  land = [[int(x) for x in input().split()] for _ in range(N)]
  visited = [[0] * N for _ in range(N)]
  direction = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # ìƒ, í•˜, ì¢Œ, ìš°
  ```

  `visited` : ë°©ë¬¸ ì—¬ë¶€ì™€ ë‹¤ë¦¬ì˜ ê¸¸ì´ë¥¼ ë‚˜íƒ€ë‚´ëŠ” 2ì°¨ì› ë°°ì—´
  `direction` : BFS ì‹œ ìƒí•˜ì¢Œìš°ë¡œ íƒìƒ‰ì„ í•˜ê¸° ìœ„í•œ ë°°ì—´

<br />

- **ì„¬ë“¤ì„ êµ¬ë³„í•˜ê¸° ìœ„í•œ BFS**

  ```python
  island_id = 2
  for i in range(N):
      for j in range(N):
          if land[i][j] == 1 and visited[i][j] == 0:
              find_island(i, j)
              island_id += 1
  ```

  ```python
  def find_island(start_x, start_y):
      queue = deque([(start_x, start_y)])
      visited[start_x][start_y] = 1
      while queue:
          i, j = queue.popleft()
          for d in direction:
              x, y = i + d[0], j + d[1]
              if 0 <= x < N and 0 <= y < N:
                  if visited[x][y] == 0 and land[x][y] == 1:
                      queue.append((x, y))
                      visited[x][y] = 1
                  elif land[x][y] == 0:
                      land[i][j] = island_id
  ```

  BFS ë¥¼ ì‹¤ì‹œí•˜ì—¬ ê° ì„¬ë§ˆë‹¤ ê³ ìœ í•œ id `island_id` ë¥¼ ë¶€ì—¬í•œë‹¤. ì´ ë•Œ í›„ì— ìˆì„ BFS ì‹œê°„ì„ ì¤„ì´ê¸° ìœ„í•´ ìƒí™”ì¢Œìš°ë¡œ 0ì´ ìˆëŠ” (ë°”ë‹¤ì™€ ê·¼ì ‘í•´ìˆëŠ”) ì›ì†Œ(ìœ¡ì§€)ì—ë§Œ idë¥¼ ì¤€ë‹¤.

<br />

- **ê°€ì¥ ì§§ì€ ë‹¤ë¦¬ë¥¼ ì°¾ëŠ” BFS**

  ```python
  bridge = sys.maxsize
  for i in range(2, island_id):
      find_bridge(i)
  print(bridge)
  ```

  ```python
  def find_bridge(id):
      global bridge
      queue = deque()
      for i in range(N):
          for j in range(N):
              if land[i][j] == id: queue.append((i, j))
      visited = [[0] * N for _ in range(N)]
      while queue:
          i, j = queue.popleft()
          for d in direction:
              x, y = i + d[0], j + d[1]
              if 0 <= x < N and 0 <= y < N:
                  # ë°”ë‹¤ì¸ ê²½ìš°
                  if land[x][y] == 0 and visited[x][y] == 0:
                          visited[x][y] = visited[i][j] + 1
                          queue.append((x, y))
                  # ë‹¤ë¥¸ ì„¬ì¸ ê²½ìš°
                  elif land[x][y] > 1 and land[x][y] != id:
                      bridge = min(bridge, visited[i][j])
                      return
  ```

  2ì¤‘ ë°˜ë³µë¬¸ì„ í†µí•´ ì¶œë°œí•˜ëŠ” ì„¬ì˜ idë¥¼ ê°€ì§„ ì›ì†Œ(ìœ¡ì§€)ì˜ ì¸ë±ìŠ¤ë¥¼ `queue`ì— appendí•œë‹¤. ì´í›„ BFS ë¥¼ ì‹¤ì‹œí•˜ì—¬ ìœ„ ì½”ë“œì™€ ê°™ì´ ë°”ë‹¤ì¸ ê²½ìš° `visited` ê°’ì„ ì—…ë°ì´íŠ¸í•˜ê³ , ë‹¤ë¥¸ ì„¬ì¸ ê²½ìš° `bridge` ê°’ì„ ìµœì†Œê°’ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•œë‹¤.

<br />
<br />

## ğŸ›  Code

```python
import sys
from collections import deque
input = sys.stdin.readline


def find_island(start_x, start_y):
    queue = deque([(start_x, start_y)])
    visited[start_x][start_y] = 1
    while queue:
        i, j = queue.popleft()
        for d in direction:
            x, y = i + d[0], j + d[1]
            if 0 <= x < N and 0 <= y < N:
                if visited[x][y] == 0 and land[x][y] == 1:
                    queue.append((x, y))
                    visited[x][y] = 1
                elif land[x][y] == 0:
                    land[i][j] = island_id


def find_bridge(id):
    global bridge
    queue = deque()
    for i in range(N):
        for j in range(N):
            if land[i][j] == id: queue.append((i, j))
    visited = [[0] * N for _ in range(N)]
    while queue:
        i, j = queue.popleft()
        for d in direction:
            x, y = i + d[0], j + d[1]
            if 0 <= x < N and 0 <= y < N:
                if land[x][y] == 0 and visited[x][y] == 0:
                        visited[x][y] = visited[i][j] + 1
                        queue.append((x, y))
                elif land[x][y] > 1 and land[x][y] != id:
                    bridge = min(bridge, visited[i][j])
                    return


N = int(input())
land = [[int(x) for x in input().split()] for _ in range(N)]
visited = [[0] * N for _ in range(N)]
direction = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # ìƒ, í•˜, ì¢Œ, ìš°

island_id = 2
for i in range(N):
    for j in range(N):
        if land[i][j] == 1 and visited[i][j] == 0:
            find_island(i, j)
            island_id += 1

bridge = sys.maxsize
for i in range(2, island_id):
    find_bridge(i)
print(bridge)

```

## ğŸ“ Review

í•œë²ˆì˜ BFSë¡œ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ ì•„ì´ë””ì–´ë¥¼ êµ¬ìƒí•˜ëŠë¼ ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë ¸ë‹¤.

ê²°êµ­ BFSë¥¼ ë‘ë²ˆ ì‹œí–‰í•˜ëŠ” ê²ƒì„ ì„ íƒí–ˆê³ , ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆì—ˆë‹¤.

**ì‹œê°„ì´ˆê³¼**ê°€ í•œë²ˆ ë°œìƒí–ˆëŠ”ë° ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ë‘ë²ˆì§¸ BFS ì—ì„œ ìƒí•˜ì¢Œìš°ì— ë‹¤ë¥¸ ì„¬ì´ ìˆì„ ê²½ìš° **return** í•˜ëŠ” ì½”ë“œë¥¼ ì¶”ê°€í–ˆë‹¤.

ê·¸ ì´ìœ ëŠ” ê°€ì¥ ë¨¼ì € ë‹¤ë¥¸ ì„¬ì— ë„ì°©í•˜ëŠ” ê²½ìš°ê°€ í•­ìƒ ê°€ì¥ ìµœì†Œì˜ `bridge` ê°’ì´ë¼ ìƒê°í–ˆê¸° ë•Œë¬¸ì´ë‹¤.

<br />
<br />

**Source:**

https://www.acmicpc.net/problem/2146
