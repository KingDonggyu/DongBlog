---
date: "2022-02-09"
title: "[Programmers] 42576번: 완주하지 못한 선수 / 42578번: 위장"
category: "Algorithm"
categoryColor: "#6196cc"
tags: ["Programmers", "Python", "Hash"]
thumbnail: "./images/Programmers.png"
---

## 🔍 Algorithm

**Hash**

## 💻 Language

**Python**

# 42576번: 완주하지 못한 선수

<hr />

## 📍 Logic

**Problem: "완주하지 못한 선수의 이름을 return (참가자 중에는 동명이인이 있을 수 있습니다.)"**

💡 선수의 이름을 Key, 동명이인의 수를 Value로 한 **딕셔너리**를 생성한다.

- 반복문을 통해 `completion` 에 Key가 있을 경우 Value를 -1 한다.

- 그 후, 0이 아닌 Key(완주하지 못한 선수의 이름)를 찾아 return한다.

## 🛠 Code

```python
def solution(participant, completion):
    answer = ''
    n = len(participant)
    player = dict.fromkeys(participant, 0)
    
    for i in range(n):
        player[participant[i]] += 1
        if i >= n-1: continue
        player[completion[i]] -= 1
    
    for key, value in player.items():
        if value != 0:
            answer = key
            break
    
    return answer
```

<br />

# 42578번: 위장

<hr />

## 📍 Logic

**Problem: "서로 다른 옷의 조합의 수를 return (스파이는 하루에 최소 한 개의 의상은 입습니다.)"**

💡 의상 종류의 이름을 Key, 해당 종류의 의상 수를 Value로 한 **딕셔너리**를 생성한다.

- 만약 해당 종류가 x라 할때,

  `x의 의상 수 * (x를 제외한 나머지 종류의 의상수+1)` 을 반복문을 통해 모두 더한다.

  - `x를 제외한 나머지 종류`에 이미 수행한 의상 종류는 포함하지 않는다.

  - `의상수+1` 은 해당 종류의 의상을 입지 않는 경우를 따지기 위함이다.

## 🛠 Code

```python
def solution(clothes):
    answer = 0
    n = len(clothes)
    clo = dict.fromkeys(map(lambda x:x[1], clothes), 0)

    for i in range(n):
        clo[clothes[i][1]] += 1

    for i in range(n):
        if clothes[i][1] not in clo:
            continue
            
        x = clo[clothes[i][1]]
        del clo[clothes[i][1]]
        
        for v in clo.values():
            x *= (v+1)
        
        answer += x

    return answer
```

<br />

## 📝 Review

두 문제 모두 비슷한 성향으로, 딕셔너리를 활용하면 쉽게 해결할 수 있는 문제이다.

코드를 더 간결하고 효율적이게 업그레이드할 수 있을 것 같지만..

안하겠다. 😝

<br />
<br />

## ※ Source

https://programmers.co.kr/learn/courses/30/lessons/42576
https://programmers.co.kr/learn/courses/30/lessons/42578
